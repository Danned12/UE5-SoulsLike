{"UserId":"43d98bd1-2838-409a-8f38-e7d49097353d","ChatId":"15246E424CE6A6D26F6C37860CA6FFBF","Title":"","CreationTime":"2025-10-17T11:24:51.315Z","UpdateTime":"2025-10-17T12:20:34.226Z","ChatMode":{"chat_mode":"ludus_agent","display_text":"Ludus Agent","is_agent_mode":true},"Messages":[{"role":"user","message_blocks":[{"type":"text","content":"In Player_BP in EnhancedInputAction IA_Roll Im trying to implement roll system that will roll in direction by looking on movement button pressed with cancelation function in EnhancedInputAction IA_Move. But it doesnt work and my character in rolling in only one deraction"}]},{"role":"assistant","message_blocks":[{"type":"text","content":"Let me examine your Player_BP blueprint to understand the current roll system implementation and identify why it's only rolling in one direction."},{"type":"checkpoint","info":{"id":"1f0ab4c7-4793-6c36-8000-373f3ff8adde"}},{"type":"tool_call","info":{"name":"read_blueprint","input":{"blueprint":"/Game/Blueprint/Player_BP.Player_BP","mode":"overview"},"reply_id":"tool_reply:read_blueprint:43d98bd1-2838-409a-8f38-e7d49097353d:15246E424CE6A6D26F6C37860CA6FFBF:toolu_012GPvTEW4TeJif7EdpG2Z73","metadata":null}},{"type":"tool_result","info":{"name":"read_blueprint"}},{"type":"checkpoint","info":{"id":"1f0ab4c7-79a1-67d5-8001-f92effe311f8"}},{"type":"checkpoint","info":{"id":"1f0ab4c7-88e7-6898-8002-21961dbf2c46"}},{"type":"tool_call","info":{"name":"read_blueprint","input":{"blueprint":"/Game/Blueprint/Player_BP.Player_BP","mode":"balanced"},"reply_id":"tool_reply:read_blueprint:43d98bd1-2838-409a-8f38-e7d49097353d:15246E424CE6A6D26F6C37860CA6FFBF:toolu_01Fbkr3N4p97Fy7Yt82hjxoN","metadata":null}},{"type":"tool_result","info":{"name":"read_blueprint"}},{"type":"checkpoint","info":{"id":"1f0ab4c7-af94-6326-8003-f55417e8cb9c"}},{"type":"checkpoint","info":{"id":"1f0ab4c7-bf9f-6d12-8004-f19ddff6860f"}},{"type":"text","content":"Looking at your Player_BP blueprint, I can see the issue with your roll system. The problem lies in how the roll direction is being determined and calculated. Here are the main issues:\n\n## Current Problems:\n\n1. **Complex Key Detection System**: You're using a complex system to detect individual movement keys (W, A, S, D) pressed simultaneously, which can be unreliable during real gameplay.\n\n2. **Roll Direction Calculation**: The roll angle calculation uses `Atan2` on the `ProcessedRollDirection`, but this vector might be zero or incorrect due to the key detection logic.\n\n3. **Timing Issues**: The roll direction is calculated when the roll button is pressed, but the movement input might not be accurately captured at that exact moment.\n\n## Recommended Solution:\n\nInstead of detecting individual keys, use the **current movement vector** from your Enhanced Input Action directly. Here's how to fix it:\n\n### Step 1: Simplify the Roll Direction Logic\n\n1. **Remove the complex key detection system** (all the `IsInputKeyDown` nodes for A, D, W, S in the roll logic).\n\n2. **Use `CurrentMoveVector` directly** - you already store this in your `IA_Move` triggered event.\n\n### Step 2: Fix the Roll Angle Calculation\n\nReplace the current roll direction calculation with:\n\n```\nCurrentMoveVector (Vector2D) → Atan2 → RadiansToDegrees → Add (-90) → SetActorRotation\n```\n\n### Step 3: Add a Fallback for No Movement\n\nWhen the player isn't moving during roll, use the **current control rotation** as the roll direction:\n\n```\nBranch: If CurrentMoveVector length > 0.1\n  → True: Use calculated angle from movement\n  → False: Use current control rotation yaw\n```\n\n### Step 4: Alternative Simplified Approach\n\nFor an even simpler solution, you could:\n\n1. **Store the last movement direction** as a variable when the player moves\n2. **Use this stored direction** for rolling when no current movement is detected\n3. **Fall back to forward direction** if no previous movement exists\n\nWould you like me to help you implement any of these solutions? The key is to rely on the Enhanced Input system's movement vector rather than manually checking individual key states."},{"type":"checkpoint","info":{"id":"1f0ab4c8-9169-6767-8005-f16110347c8c"}}]},{"role":"user","message_blocks":[{"type":"text","content":"step by step"}]},{"role":"assistant","message_blocks":[{"type":"checkpoint","info":{"id":"1f0ab4c8-9169-6767-8005-f16110347c8c"}},{"type":"checkpoint","info":{"id":"1f0ab4cf-74ab-691c-8006-478d6f53b01c"}},{"type":"text","content":"I'll provide a step-by-step guide to fix your roll system. Let's simplify it by using the `CurrentMoveVector` directly instead of the complex key detection system.\n\n## Step-by-Step Fix:\n\n### **Step 1: Clean Up the Roll Logic**\n1. **In the IA_Roll_0 event**, find the nodes after `DoOnce_0.Completed`\n2. **Delete these nodes** that are causing the complexity:\n   - All the `IsInputKeyDown` nodes (for W, A, S, D keys)\n   - All the `ANDBoolean` operations \n   - The `SelectFloat_3` and `SelectFloat_4` nodes\n   - The complex `ProcessedRollDirection` calculation\n\n### **Step 2: Create Simple Roll Direction Logic**\nReplace the deleted section with this simpler approach:\n\n1. **After `DoOnce_0.Completed`**, add a **Branch** node\n2. **Set Branch condition**: `Vector2D Length` → connect `CurrentMoveVector` \n3. **Compare**: `Float > Float` → set second value to `0.1`\n\n### **Step 3: Handle Movement-Based Rolling (Branch = True)**\nWhen player is moving during roll:\n\n1. **From Branch True output**: \n   - Add `Atan2 (Radians)` node\n   - Connect `CurrentMoveVector.Y` to **Y** input\n   - Connect `CurrentMoveVector.X` to **X** input\n\n2. **Convert to degrees**:\n   - Add `Radians to Degrees` node\n   - Connect `Atan2` output to input\n\n3. **Adjust for forward direction**:\n   - Add `Float + Float` node  \n   - Connect `Radians to Degrees` output to **A**\n   - Set **B** to `-90.0`\n\n### **Step 4: Handle No-Movement Rolling (Branch = False)**\nWhen player isn't moving during roll:\n\n1. **From Branch False output**:\n   - Add `Get Control Rotation` node\n   - Add `Break Rotator` node\n   - Connect rotation to Break Rotator\n   - Use the **Yaw** output\n\n### **Step 5: Combine Both Paths**\n1. **Add a `Select Float` node**:\n   - **A** input: Connect the **Yaw** from no-movement path\n   - **B** input: Connect the calculated angle from movement path  \n   - **Pick A** input: Connect to Branch condition (inverted with `NOT Boolean`)\n\n### **Step 6: Apply the Roll Rotation**\n1. **Connect Select Float output** to `SetActorRotation` **Yaw** input\n2. **Keep the rest** of your roll logic (animation, delay, etc.) unchanged\n\n### **Step 7: Remove Unused Variables**\nClean up your blueprint by removing these unused variables:\n- `ProcessedRollDirection` \n- `RollDirection`\n- All the movement key detection arrays if not used elsewhere\n\n### **Step 8: Test the System**\n\n**Test Cases:**\n1. **Roll while moving forward** → Should roll forward\n2. **Roll while moving diagonally** → Should roll in diagonal direction  \n3. **Roll while standing still** → Should roll in camera facing direction\n4. **Roll while strafing** → Should roll left/right correctly\n\n### **Alternative Simplified Version:**\nIf you want an even simpler approach, just use:\n\n```\nCurrentMoveVector → Atan2 → Radians to Degrees → Add(-90) → SetActorRotation\n```\n\nAnd add a fallback: if `CurrentMoveVector` length is near zero, use `Get Control Rotation.Yaw` instead.\n\nThis approach eliminates all the complex key detection and uses the reliable Enhanced Input system data you're already capturing. Would you like me to help you implement any specific part of these steps?"},{"type":"checkpoint","info":{"id":"1f0ab4cf-74e6-6e1d-8007-37d4d9ab6562"}},{"type":"checkpoint","info":{"id":"1f0ab4d0-4bf2-6f26-8008-cbd72f2e88d4"}}]},{"role":"user","message_blocks":[{"type":"text","content":"Currently it works partly first problem is that my character is moving by depending on camera so cameras front is characters front but roll is procided on fixed front back and so on"}]},{"role":"assistant","message_blocks":[{"type":"checkpoint","info":{"id":"1f0ab4d0-4bf2-6f26-8008-cbd72f2e88d4"}},{"type":"checkpoint","info":{"id":"1f0ab4f3-1eed-6c3a-800a-90740a440cf2"}},{"type":"text","content":"Ah, I see the issue! Your character movement is **camera-relative** (camera forward = character forward), but your roll system is using the raw input values which are **world-relative/fixed directions**. \n\nThe `CurrentMoveVector` contains values like (-1, 0) for left, (0, 1) for forward, etc., but these need to be **transformed to match your camera's orientation**.\n\n## Solution: Transform Roll Direction to Camera Space\n\nHere's how to fix it step-by-step:\n\n### **Step 1: Get Camera Rotation**\nIn your roll logic, after `DoOnce_0.Completed`:\n\n1. Add `Get Control Rotation` node\n2. Add `Break Rotator` node \n3. Connect the rotation output to Break Rotator input\n4. We'll use the **Yaw** output\n\n### **Step 2: Transform Movement Vector to World Space**\n\nInstead of using `CurrentMoveVector` directly for `Atan2`, transform it first:\n\n1. **Create Right Vector**:\n   - Add `Get Right Vector` node\n   - Connect Control Rotation **Yaw** to the Rotator input (set Pitch and Roll to 0)\n\n2. **Create Forward Vector**:\n   - Add `Get Forward Vector` node  \n   - Connect Control Rotation **Yaw** to the Rotator input (set Pitch and Roll to 0)\n\n3. **Scale the vectors**:\n   - Add `Vector * Float` for Right Vector → multiply by `CurrentMoveVector.X`\n   - Add `Vector * Float` for Forward Vector → multiply by `CurrentMoveVector.Y`\n\n4. **Combine the vectors**:\n   - Add `Vector + Vector` node\n   - Connect scaled Right and Forward vectors\n\n### **Step 3: Convert World Vector to Rotation**\n\n1. Add `Find Look at Rotation` node:\n   - **Start**: Character's current location (`Get Actor Location`)\n   - **Target**: Current location + transformed movement vector (`Vector + Vector`)\n\n2. Add `Break Rotator` on the result\n3. Use the **Yaw** output for your roll rotation\n\n### **Alternative Simpler Method:**\n\nIf the above seems complex, here's a simpler approach:\n\n1. **Get the camera's current yaw**: `Get Control Rotation → Break Rotator → Yaw`\n\n2. **Calculate input angle**: `CurrentMoveVector → Atan2 → Radians to Degrees`\n\n3. **Add camera yaw to input angle**: `Float + Float`\n   - **A**: Camera Yaw\n   - **B**: Input angle\n   - **Result**: Camera-relative roll direction\n\n4. **Subtract 90 degrees if needed** for forward alignment: `Float + Float` (with -90)\n\n### **Step 4: Handle No Movement Case**\n\nWhen `CurrentMoveVector` length is near zero:\n- Use `Get Control Rotation → Yaw` directly (camera forward direction)\n\n### **Quick Test:**\n- **Move forward + roll**: Should roll in camera's forward direction\n- **Move left + roll**: Should roll in camera's left direction  \n- **Move diagonally + roll**: Should roll diagonally relative to camera\n- **Stand still + roll**: Should roll forward relative to camera\n\nThis will make your roll system consistent with your camera-relative movement system. Would you like me to elaborate on any of these steps?"},{"type":"checkpoint","info":{"id":"1f0ab4f4-0061-60db-800b-a65c315213bf"}}]},{"role":"user","message_blocks":[{"type":"text","content":"can you be more percise on what goes where"}]},{"role":"assistant","message_blocks":[{"type":"checkpoint","info":{"id":"1f0ab4f4-0061-60db-800b-a65c315213bf"}}]},{"role":"user","message_blocks":[{"type":"text","content":"I used Alternative Simpler Method and it works but when I want to roll right and left its inverted and rolls in oposite deraction"}]},{"role":"assistant","message_blocks":[{"type":"checkpoint","info":{"id":"1f0ab52d-10e4-6aae-800e-583b38032388"}},{"type":"checkpoint","info":{"id":"1f0ab53a-2519-6424-800d-536647763238"}},{"type":"text","content":"The left/right inversion is a common issue with coordinate systems. The problem is that the `CurrentMoveVector.X` values or the angle calculation is flipped for the horizontal axis.\n\n## Quick Fix for Left/Right Inversion:\n\n### **Option 1: Negate the X Component**\nBefore the `Atan2` calculation:\n\n1. **Add `Float * Float` node**:\n   - **A**: `CurrentMoveVector.X`  \n   - **B**: `-1.0`\n   - This inverts the X-axis\n\n2. **Connect the result** to `Atan2` **X** input instead of the direct `CurrentMoveVector.X`\n\n3. **Keep `CurrentMoveVector.Y`** connected to `Atan2` **Y** input as is\n\n### **Option 2: Adjust the Final Angle**\nAfter adding Camera Yaw + Input Angle:\n\n1. **Add another `Float * Float` node**:\n   - **A**: Your current result (Camera Yaw + Input Angle)\n   - **B**: `-1.0`\n   - This inverts the entire angle\n\n### **Option 3: Modify the Angle Offset**\nInstead of subtracting 90 degrees, try:\n\n1. **Change the final offset** from `-90` to `+90` (or vice versa)\n2. **Or try** `+270` instead of `-90`\n\n## Test Each Option:\n\n**Try Option 1 first** (negate X input), as it's the most common solution:\n\n- Move right → Should roll right\n- Move left → Should roll left  \n- Forward/backward should still work correctly\n\nIf Option 1 doesn't work, try Option 2. If both axes get inverted with Option 2, then Option 3 with the angle offset adjustment should work.\n\n## Debug Tip:\n\nAdd a **Print String** node to see the values:\n- Print `CurrentMoveVector.X` to see if right movement is positive or negative\n- Print the final angle to see what values you're getting\n\nThis will help identify exactly where the inversion is happening. Which option would you like to try first?"},{"type":"checkpoint","info":{"id":"1f0ab53a-d4cc-625b-800e-4f3ff6d4dcde"}}]}],"Mapping":{"node_agent_names":{"pairs":[{"first":"ADEFBBDA4B47762A07A05FBA01000DAB","second":"ConstructionScript_0"},{"first":"DE2F432B40720C3C2E667780E5C90E47","second":"CastToPlayerController_0"},{"first":"DEC63E6F4FA5D1C6D77CDAA69A3665B7","second":"EventBeginPlay_0"},{"first":"8660AE93468D1B3F20B2108487CA3DED","second":"IsValid_0"},{"first":"FBF899404F21A0667C42FCA5D8BF45B3","second":"GetController_0"},{"first":"8257F383485E00F09814F8937491D337","second":"GetEnhancedInputLocalPlayerSubsystem_0"},{"first":"087E7C7F4376411E23405C9894A062F4","second":"AddRerouteNode..._0"},{"first":"D00F24C04D6578B7A08E61A0DD8A08AE","second":"AddMappingContext_0"},{"first":"350400164DC7FDAB561AAB83387D9334","second":"AddControllerYawInput_0"},{"first":"937F6788444FB33B39C6F185182A3A83","second":"float*float_0"},{"first":"A16D28944928D07E71F5AFA0FF78FA74","second":"IA_Look_0"},{"first":"4E1B2A974ABE23DDC460CAAB0FA06136","second":"AddControllerPitchInput_0"},{"first":"1ECD54264029A3EB4897A9A22DBFF41C","second":"AddComment..._0"},{"first":"78BDDC734363B6813DCB21BBB26255A4","second":"DetectMovementKeys_0"},{"first":"DB6A58FA4243687BD5A780B90F680C4C","second":"AddRerouteNode..._1"},{"first":"E57749F14D22B9783FE9D48A8B02686D","second":"Set_0"},{"first":"3C4BDC7D4FD01B20D271A3AA6CC574BB","second":"AddRerouteNode..._2"},{"first":"11FC62734D52BD10F5F9E39E91E5D9DE","second":"IA_Move_0"},{"first":"9D66E01E4CCC35188EA69B94B79F81C0","second":"AddMovementInput_0"},{"first":"6B1402E54C319CF133DAD9B1F59FD2C6","second":"GetRightVector_0"},{"first":"72A001864FBDD99AE609DFB462062A12","second":"AddRerouteNode..._3"},{"first":"DA5A14124BB8ACED5D3561AFE3D338FC","second":"AddMovementInput_1"},{"first":"DF20350A4FD1C187892094B10F260A53","second":"GetControlRotation_0"},{"first":"94D52D104BB3D70254B290B39640ABFA","second":"GetForwardVector_0"},{"first":"4484CA8149572B8BFA4650B915B5299D","second":"GetControlRotation_1"},{"first":"FA6B5D8B4C89449EFDAA03A9C13A497A","second":"AddRerouteNode..._4"},{"first":"4C4A77FD4ABDF1E2139269AEDAE9EFB9","second":"AddComment..._1"},{"first":"06E21BED463461857E7DE289AA32E4FE","second":"SetMaxWalkSpeed_0"},{"first":"488D48884FFD4D809A063493EEC720AD","second":"SetMaxWalkSpeed_1"},{"first":"3362C7174B5BB46F515C24B1C9FAED3E","second":"IA_Running_0"},{"first":"2104EBBA49B6BDBFD2DFEC99E7145C40","second":"GetCharacterMovement_0"},{"first":"B1FD4E3A4FC7C44516D8E7BB75962F28","second":"AddComment..._2"},{"first":"69FD1BE84B95F43565591DA3D64376DF","second":"DoOnce_0"},{"first":"B1085E6A4CE920A833F01F92030B5A97","second":"IA_Roll_0"},{"first":"DD17CA3E4D58C8BB01CCFAA0A09D486C","second":"SetRollAngle_0"},{"first":"0A0BB88C4FD03CE990C944AE8EB60518","second":"PlayAnimMontage_0"},{"first":"330B13AB414718668A888FB2A25A2B97","second":"SelectFloat_0"},{"first":"FC300DB94234813ADF7BD0A27FE173A1","second":"SetActorRotation_0"},{"first":"398D874A4FE8AECAE78097971F0A291C","second":"GetActorTransform_0"},{"first":"3699594D4252F54F58EFF7BC8E7DF11C","second":"AddRerouteNode..._5"},{"first":"E25D90594CAE37B5FD92A88096F0BE1C","second":"Delay_0"},{"first":"0866A8F14DA5CACEB011A687058805E6","second":"AddRerouteNode..._6"},{"first":"DD2C95AD483351EDEA9CA899535959FB","second":"Set_1"},{"first":"4AB71A1E44C33F582538DAA9D849F819","second":"ForEachLoop_0"},{"first":"94DB9C6243454E3BFD3FA3873B3354C2","second":"DetectMovementKeys_1"},{"first":"3E5F9A934A30DE8A5AED959F274D049C","second":"AddRerouteNode..._7"},{"first":"19B568074C6EE0A51896C2A423C63BF5","second":"SetArrayElem_0"},{"first":"F8A658524A679BC74098C097CEE59E08","second":"AddRerouteNode..._8"},{"first":"89BB844F4D852A24C946D3841BF6CB27","second":"Branch_0"},{"first":"2CF8899F4B0D302ED8FA768A763F8C6B","second":"AddRerouteNode..._9"},{"first":"E1EED91040BEF8FABA6B238117092B3E","second":"AddRerouteNode..._10"},{"first":"315F7D034186D8C88A6D75B8479555B5","second":"Get(aref)_0"},{"first":"EA55DC8D4E6C88ED2F7A44B6EBDBAE59","second":"AddRerouteNode..._11"},{"first":"AE036AA74595CCABCFE325AA89C9A651","second":"AddRerouteNode..._12"},{"first":"154D048445835CF294D9788098CE8545","second":"GetMovementKeys_0"},{"first":"C63F319E49CD319999297081080CCD2E","second":"AddRerouteNode..._13"},{"first":"A4BC18794AC8B1454C1A40A263674030","second":"AddRerouteNode..._14"},{"first":"43718F51469E510089089AB129BE3A1A","second":"IsInputKeyDown_0"},{"first":"3005819045F14E536FB7B9901FDC805A","second":"AddRerouteNode..._15"},{"first":"3C55609E43ACE50AE6F75F86089E832E","second":"GetKey_0"},{"first":"2CE3AA974D367E22B2AEC9B4190909E6","second":"AddRerouteNode..._16"},{"first":"E0ADF9CB41ECF4D26E86A294512A18B8","second":"AddRerouteNode..._17"},{"first":"42D4C6E14126F6DC12236A9342F8155E","second":"AddRerouteNode..._18"},{"first":"C506E4584AC566DE2E2AC69CF3BF244F","second":"AddRerouteNode..._19"},{"first":"924F2B264BC8BEF4E52BB1BA1E5E2AB5","second":"GetCurrentMovementKeys_0"},{"first":"700ED16E45C62EE34E963194D4851DE0","second":"SetArrayElem_1"},{"first":"3FBD536B41DDE5EB8F68E8871D8994B1","second":"AddComment..._3"},{"first":"56840ACD48AE52A1CB931EAA1FC66D0B","second":"AddRerouteNode..._20"},{"first":"4E50F74E4A3869231B2AC89F4BB45417","second":"GetPlayerController_0"},{"first":"89A939A445D33D6FC6FAA39B5AD91C0E","second":"AddRerouteNode..._21"},{"first":"2D89FDF942481AE80229A78B34D37A2B","second":"Get(aref)_1"},{"first":"9989E8574D95CAD3808F11AD9EBDFAF7","second":"ForEachLoop_1"},{"first":"47215A894BD7C7D6B7C5B9BD5767DAA4","second":"GetCurrentMovementKeys_1"},{"first":"D479DAE74B2F7D975E25D6B58CCFC672","second":"EqualExactly(String)_0"},{"first":"E13D897D46D9F9AEFD79DBBD07A8B66C","second":"Get(aref)_2"},{"first":"D9D94B7E4823A9D27B4DC09738234D72","second":"GetMovementKeys_1"},{"first":"52C5E59A4B33AE118DF6FC9E7E8009AD","second":"Branch_1"},{"first":"B40B893E470BBB9AC5C8709C23EDDC17","second":"UpdateCurrentRotations_0"},{"first":"B6D9B5DF4707D5DBE717408E7B7BD974","second":"EventTick_0"},{"first":"DA318D8042D27B50C05C2A867509FE67","second":"ForEachLoop_2"},{"first":"01B45C534FC4B1F40DD1D2B0C2078E9B","second":"UpdateCurrentRotations_1"},{"first":"9297A8C74D736808E65D7EA46A2706AF","second":"BreakRotator_0"},{"first":"63FB598344AE72C0FA67CBA07EC5F163","second":"GetControlRotation_2"},{"first":"AC4D78BF418155AC7A762DA75DC180F7","second":"float+float_0"},{"first":"F614DC8D4C523DDFD202D4BC58CD2E6C","second":"GetCurrentRotations_0"},{"first":"E8F85EEF450FCC061E57D99105DE87EF","second":"SetArrayElem_2"},{"first":"6F515F0D460C0ABB34564286FEDE107B","second":"Get(aref)_3"},{"first":"429F35E749B5E5BDFDE07F9163C92215","second":"GetAllRotations_0"},{"first":"5C343B344BD48D3F8424128720640505","second":"Get_0"},{"first":"97DC98764C740881E88EFB86B7359826","second":"GetPlayerController_1"},{"first":"109DC48A4CD76F2F4F362CA576134035","second":"ANDBoolean_0"},{"first":"17B066D74BFC6059122D1EA9B6EFB19D","second":"IsInputKeyDown_1"},{"first":"E167185745087BD5780AF795A0D516A2","second":"IsInputKeyDown_2"},{"first":"A695150D46442B811CF4D08F3BB9BF94","second":"SelectFloat_1"},{"first":"DF4594834686D50E0EA066A52AC42018","second":"AddRerouteNode..._22"},{"first":"2E78897C45BEC79175B590835236B47C","second":"GetPlayerController_2"},{"first":"C08E04984319A3AE7ED2A2A29C86506F","second":"ANDBoolean_1"},{"first":"8A14492C48772A73C4037C8CFB7DEF80","second":"IsInputKeyDown_3"},{"first":"3394956142ACEFE267771D8C56A7C759","second":"IsInputKeyDown_4"},{"first":"6C05159A42DD61DAC1466EBDA0D235C3","second":"SelectFloat_2"},{"first":"16A4399E4742C5BC5B2F96B53F9879E1","second":"AddRerouteNode..._23"},{"first":"C5239A8A47E9F61AF5927DAD3F8DCF01","second":"AddRerouteNode..._24"},{"first":"0059D09145D5EA90C15DE08C6D153747","second":"AddRerouteNode..._25"},{"first":"755FD8D0480BF8EA9B9223B00363B44B","second":"AddRerouteNode..._26"},{"first":"CBA9FCA5486326332C3F168B29B75091","second":"AddComment..._4"},{"first":"69398EB543C7153F2E7A78AB7A8A8064","second":"AddComment..._5"},{"first":"869F5ECF4BC879DDD23E9194AE980A73","second":"AddComment..._6"},{"first":"9AC679B444EFBD59EB00E0BB53EBA23F","second":"FlipFlop_0"},{"first":"F4FCCA34488E31E0C5DE8898782CF973","second":"IA_Target_0"},{"first":"41CD698348559E8CA0F2D795E0472577","second":"SetIsTargeting_0"},{"first":"40A88D794B3957F891AC34902687AABC","second":"SetIsTargeting_1"},{"first":"FAE1136940542E5125B80B9966FD33F9","second":"SphereTraceForObjects_0"},{"first":"092DCDCD4F2F693BC874C99CBF6B8C93","second":"SetCurrentTarget_0"},{"first":"BC5ACF9B4780CFBEF7C592B1867EA083","second":"Branch_2"},{"first":"4575DEB64CB4CCCE98FC68AB8BCB6E70","second":"AddRerouteNode..._27"},{"first":"EDC8F7C24D1664AFF332A5A39BBD9206","second":"AddRerouteNode..._28"},{"first":"1790C2624225F13A97419F95085A6CA8","second":"GetTargetLocationWidth_0"},{"first":"92900C4F4C4FE101005F9480F7D89C46","second":"MakeArray_0"},{"first":"FADB0C954E31F328EB91CC966F221AA2","second":"BreakHitResult_0"},{"first":"5158F369437C799CCAC60399BBBC6E17","second":"vector+vector_0"},{"first":"326BD99440CBC9EE19A895A41AF74D1F","second":"GetActorLocation_0"},{"first":"D7755D534FF9393BA2C783A818E1F7EF","second":"GetWorldRotation_0"},{"first":"5508336941E17A7A50FB4FAF7E3677F3","second":"GetCamera_0"},{"first":"E03D051F412C5B91B06277974067C943","second":"GetForwardVector_1"},{"first":"7E775B9046D681B4C52938A3A5822B61","second":"vector*vector_0"},{"first":"401D240D4EEB0784B195A7B4B7940731","second":"GetTargetLocationRange_0"},{"first":"E5EB015A4080175D3D0EF893F03A193E","second":"SetCurrentTarget_1"},{"first":"05457F20448EE68D17AB1E9CDC9DB7BA","second":"SetControlRotation_0"},{"first":"62AE587B495AB35FAD230CB5F656968A","second":"GetController_1"},{"first":"68EF32914F8782DF485ADEA0488A9E6D","second":"FindLookatRotation_0"},{"first":"05954724475FF85FD64BF38A9CBEB3BB","second":"GetActorLocation_1"},{"first":"8881D7164E6646CD2F7D87A9609D2EC4","second":"GetActorLocation_2"},{"first":"B7BA1F304FACBA3BF9564886CFB46319","second":"GetCurrentTarget_0"},{"first":"F440440D4809070D120F3BBC7A192774","second":"AddComment..._7"},{"first":"0D24495546114DCE728BE9A964D82A4A","second":"GetPlayerController_3"},{"first":"4F6B2DE9429362A77EDA54966AC9851D","second":"ANDBoolean_2"},{"first":"97C47FD04EAF7DD192238CBD4822B415","second":"IsInputKeyDown_5"},{"first":"1A6FB822449BCD67CCC52D8E7BCAE36D","second":"IsInputKeyDown_6"},{"first":"C4970B7A492AA2D887AF35AA6E13FB14","second":"SelectFloat_3"},{"first":"2D129F6A411DBBC56A5B1F8B636084DF","second":"Get_1"},{"first":"422F65F4432F286663292B88B85CFEF0","second":"GetPlayerController_4"},{"first":"B2DB81824B40680C50A7348270D9FE76","second":"ANDBoolean_3"},{"first":"B46CC77D497F01FC5F369AB667484BE6","second":"IsInputKeyDown_7"},{"first":"E7B32EE84680675D8A59B79D3E77123C","second":"IsInputKeyDown_8"},{"first":"A6929A0541B7C34424F12BACA7F21245","second":"SelectFloat_4"},{"first":"11D4CDE74EB48008B02833B23B8B618D","second":"Atan2(Radians)_0"},{"first":"5A80F21E438B21F8B7E71C82B7E69094","second":"float+float_1"},{"first":"DAB35A5F4E747AB10CD94D90882BCD6C","second":"RadiansToDegrees_0"},{"first":"09FFCAD04E6B0BDA1BA4FB8C326A2E3F","second":"GetProcessedRollDirection_0"},{"first":"329AFAD64957701C17FEF199437BC735","second":"NearlyEqual(Float)_0"},{"first":"9B04758A43BC5E3D7702DAA02922AF48","second":"Vector2DLength_0"}]}}}